eof = { eoi } // report explicitly

newline = { "\r"? ~ "\n" }

non_control_char = { "\t" | '\u{0020}'..'\u{007E}' | '\u{00A0}'..'\u{10FFFF}' }
ws_char = { " " | "\t" }
ws = @{ ws_char+ }
// Like `ws?` but emits a pair even if empty
maybe_ws = @{ ws_char* }

// Trailing underscore because `comment` is a magic rule (as is `whitespace`)
comment_ = @{ "//" ~ non_control_char* }


manifest = {
    (blank_line ~ newline)*
    ~ pm_version_tag
    ~ (newline ~ manifest_entry)*
}

manifest_entry = { metadata_section | dependencies_section | blank_line }

manifest_eof = { manifest ~ eof }

blank_line = @{ maybe_ws ~ comment_? }


// We want to do a two-pass parse here. In the first pass, gobble up anything
// that looks like a version and report errors. In the second pass, parse the
// rest.
pm_version_tag = { maybe_ws ~ "pm" ~ ws ~ "1.0" ~ maybe_ws ~ comment_? }

dependencies_section = {
    dependencies_opening_line ~ newline
    ~ (
        (dependency | blank_line)
        ~ newline
    )*
    ~ dependencies_closing_line
}

dependencies_opening_line = {
    maybe_ws ~ "dependencies" ~ maybe_ws ~ "{" ~ maybe_ws ~ comment_?
}

dependencies_closing_line = {
    maybe_ws ~ "}" ~ maybe_ws ~ comment_?
}

metadata_section = {
    metadata_opening_line ~ newline
    ~ (
        (metadata_entry | blank_line)
        ~ newline
    )*
    ~ metadata_closing_line
}

metadata_opening_line = {
    maybe_ws ~ "package" ~ maybe_ws ~ "{" ~ maybe_ws ~ comment_?
}

metadata_closing_line = {
    maybe_ws ~ "}" ~ maybe_ws ~ comment_?
}


// e.g. "  js/left-pad: ^1.2.3  // for text handling"
dependency = {
    maybe_ws
    ~ package_name
    ~ maybe_ws
    ~ colon
    ~ maybe_ws
    ~ version_constraint
    ~ maybe_ws
    ~ comment_?
}

package_name = @{
    package_name_component // namespace
    ~ "/"
    ~ package_name_component // name
}

// Note: These rules are permissive and require further validation in the Rust code.
package_name_component = {
    ('a'..'z' | 'A'..'Z' | '0'..'9' | "_" | "-")+
}

colon = { ":" }

version_constraint = {
    version_constraint_component
    ~ (
        ws
        ~ version_constraint_component
    )?

}

version_constraint_component = {
    ("^" | ">=" | "<" | "")
    ~ version
}

version = @{
    '0'..'9'
    ~ ('0'..'9' | 'a'..'z' | 'A'..'Z' | "-" | ".")*
}


metadata_entry = {
    maybe_ws
    ~ keyword
    ~ maybe_ws
    ~ colon
    ~ maybe_ws
    ~ value
    ~ maybe_ws
    ~ comment_?
}

keyword = @{ 'a'..'z' | 'A'..'Z' | '0'..'9' | "_" }


value = {
    string_value | array_value
}

string_value = {
    "\""
    ~ string_character*
    ~ "\""
}

string_character = {
    literal_character
    | escaped_quote
    | escaped_backslash
    | escaped_newline
    | escaped_tab
    | escaped_unicode
}

literal_character = {
    !"\\"
    ~ non_control_char
}

escaped_quote = { "\\\"" }

escaped_backslash = { "\\\\" }

escaped_newline = { "\\n" }

escaped_tab = { "\\t" }

escaped_unicode = {
    "\\u{"
    ~ (
          (hex)
        | (hex ~ hex)
        | (hex ~ hex ~ hex)
        | (hex ~ hex ~ hex ~ hex)
        | (hex ~ hex ~ hex ~ hex ~ hex)
        | (hex ~ hex ~ hex ~ hex ~ hex ~ hex)
    )
    ~ "}"
}

hex = {
    '0'..'9' | 'a'..'f' | 'A'..'F'
}

whitespace_with_newline = {
    (ws_char | (comment_? ~ newline))
}

array_value = {
    "["
    ~ whitespace_with_newline*
    ~ (
        value
        ~ (
            whitespace_with_newline+
            ~ value
        )*
    )?
    ~ whitespace_with_newline*
    ~ "]"
}
