eof = { eoi } // report explicitly

newline = { "\r"? ~ "\n" }

non_control_char = { "\t" | '\u{0020}'..'\u{007E}' | '\u{00A0}'..'\u{10FFFF}' }
ws_char = { " " | "\t" }
ws = @{ ws_char+ }
// Like `ws?` but emits a pair even if empty
maybe_ws = @{ ws_char* }

// Trailing underscore because `comment` is a magic rule (as is `whitespace`)
comment_ = @{ "//" ~ non_control_char* }


manifest = {
    (blank_line ~ newline)*
    ~ pm_version_tag
    ~ (newline ~ manifest_entry)*
}

manifest_entry = { metadata_section | dependencies_section | blank_line }

manifest_eof = { manifest ~ eof }

blank_line = @{ maybe_ws ~ comment_? }


// We want to do a two-pass parse here. In the first pass, gobble up anything
// that looks like a version and report errors. In the second pass, parse the
// rest.
pm_version_tag = { maybe_ws ~ "pm" ~ ws ~ "1.0" ~ maybe_ws ~ comment_? }

dependencies_section = {
    maybe_ws ~ "dependencies" ~ maybe_ws ~ block ~ maybe_ws ~ comment_?
}

dependencies_opening_line = {
    maybe_ws ~ "dependencies" ~ maybe_ws ~ "{" ~ maybe_ws ~ comment_?
}

dependencies_closing_line = {
    maybe_ws ~ "}" ~ maybe_ws ~ comment_?
}

metadata_section = {
    maybe_ws ~ "package" ~ maybe_ws ~ block ~ maybe_ws ~ comment_?
}

block = {
    "{" ~ maybe_ws ~ comment_? ~ newline
    ~ block_entry*
    ~ maybe_ws ~ "}"
}

block_entry = {
    (field | blank_line)
    ~ newline

}

version_constraint_component = {
    ("^" | ">=" | "<" | "")
    ~ version
}

version = @{
    '0'..'9'
    ~ ('0'..'9' | 'a'..'z' | 'A'..'Z' | "-" | ".")*
}


field = {
    maybe_ws
    ~ symbol
    ~ maybe_ws
    ~ arguments
    ~ comment_?
}

symbol = @{
    !("/")
    ~ ('a'..'z' | 'A'..'Z' | '0'..'9' | "_" | "-" | "/" )+
}

arguments = {
    positional_arguments
    ~ options
    ~ (block ~ maybe_ws)?
}

positional_arguments = {
    (positional_argument ~ maybe_ws)*
}

options = {
    (option ~ maybe_ws)*
}

option = {
    "TODO"
}

positional_argument = {
    string
    | list
    | version_constraint_component
}

list_item = { string | list | block }

string = {
    "\""
    ~ (
        literal_character
        | escaped_quote
        | escaped_backslash
        | escaped_newline
        | escaped_tab
        | escaped_unicode
    )*
    ~ "\""
}

literal_character = {
    !("\\" | "\"")
    ~ non_control_char
}

escaped_quote = { "\\\"" }

escaped_backslash = { "\\\\" }

escaped_newline = { "\\n" }

escaped_tab = { "\\t" }

escaped_unicode = {
    "\\u{"
    ~ (
          (hex)
        | (hex ~ hex)
        | (hex ~ hex ~ hex)
        | (hex ~ hex ~ hex ~ hex)
        | (hex ~ hex ~ hex ~ hex ~ hex)
        | (hex ~ hex ~ hex ~ hex ~ hex ~ hex)
    )
    ~ "}"
}

hex = {
    '0'..'9' | 'a'..'f' | 'A'..'F'
}

whitespace_with_newline = {
    (ws_char | (comment_? ~ newline))
}

list = {
    "["
    ~ whitespace_with_newline*
    ~ (
        list_item
        ~ (
            whitespace_with_newline+
            ~ list_item
        )*
    )?
    ~ whitespace_with_newline*
    ~ "]"
}
